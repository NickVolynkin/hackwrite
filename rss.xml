<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>hack.write()</title><link>http://hackwrite.com/</link><description>Writing about writing about development.</description><atom:link type="application/rss+xml" rel="self" href="http://hackwrite.com/rss.xml"></atom:link><language>en</language><lastBuildDate>Mon, 02 Jan 2017 21:41:21 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Simple Input Validation and Exception Handling in Python</title><link>http://hackwrite.com/posts/simple-input-validation-handling-python/</link><dc:creator>Adam Michael Wood</dc:creator><description>&lt;p&gt;If you are doing a simple terminal script in Python, and you need to validate some user-supplied input, you can put the assignment and validation in a &lt;code&gt;try&lt;/code&gt; block inside a &lt;code&gt;while&lt;/code&gt; loop.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# variable not assigned&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;# input, assignment, validation&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;If the assignment or validation fails, the loop repeats and the user has another opportunity to enter input. (You could even add a message to &lt;code&gt;except&lt;/code&gt; if you wanted to.)&lt;/p&gt;
&lt;p&gt;This came up for me in &lt;a href="https://gist.github.com/adammichaelwood/6f2e02c4156c6cc27020ce179d2e8638"&gt;a little script I wrote&lt;/a&gt; to &lt;a href="https://www.reddit.com/r/learnpython/comments/56r94z/what_python_program_have_you_created_to_make_your/d8m0hy6/?context=3"&gt;semi-automate a task&lt;/a&gt;. I needed to rate the quality of something I was looking at, and I was going for speed: Glance at the item, make a snap quality judgment, type a number.&lt;/p&gt;
&lt;p&gt;But, of course, sometimes I typed the number incorrectly, hitting a letter instead of a number. This screwed things up latter, when I tried to order all my items by quality rating.&lt;/p&gt;
&lt;p&gt;So, I cast the input to an integer inside the &lt;code&gt;try&lt;/code&gt; block, and used the &lt;code&gt;while&lt;/code&gt; loop to repeat until the &lt;code&gt;quality&lt;/code&gt; rating was assigned.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="s1"&gt;'quality'&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lnk&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;lnk&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'quality'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Quality (0-9): "&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This approach could be expanded for more complicated types of validation, and messages to the user could be added. I just wanted a quick way to deal with my fat fingers.&lt;/p&gt;</description><guid>http://hackwrite.com/posts/simple-input-validation-handling-python/</guid><pubDate>Mon, 02 Jan 2017 14:33:49 GMT</pubDate></item><item><title>Enough to Be Dangerous: The Joy of Bad Python</title><link>http://hackwrite.com/posts/enough-to-be-dangerous/</link><dc:creator>Adam Michael Wood</dc:creator><description>&lt;p&gt;As we all know, &lt;strong&gt;Learning to Code&lt;/strong&gt; is all the rage. I don't see any sign that the trend is dying down any time soon, so I might as well jump on the bandwagon here and encourage my fellow tech writers to do the same.&lt;/p&gt;
&lt;p&gt;Obviously, a lot of you already do code, or are in the process of learning. I once assumed knowing at least some coding was a requirement for being a tech writer. But it seems this isn't entirely the case. Some TWs need to be able to read and write enough code to document APIs and provide code samples --- but apparently (I have learned) most tech writers aren't doing that, and you can fake your way through that if you really need to.&lt;/p&gt;
&lt;p&gt;So, &lt;strong&gt;if you are among the majority of technical writers that don't code, this post is for you&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;We Know Too Much&lt;/h2&gt;
&lt;p&gt;When people outside the tech field suddenly decide that they are going to learn to code, they have &lt;em&gt;no idea&lt;/em&gt; how hard that actually is. All of the "Learn to Code" resources, books, sites, and bootcamps tell you that you can learn to build web and mobile apps pretty easily --- in just a few weeks, even.&lt;/p&gt;
&lt;p&gt;And when you first start coding, it seems magical. Especially if the framework does a lot for you. "Oh, wow! Is this all it takes to build an app?!"&lt;/p&gt;
&lt;p&gt;You and I know --- these people don't have any idea what they are in for, how difficult it is about to get for them, how far is the distance between local build and production deployment.&lt;/p&gt;
&lt;p&gt;I suspect this stops many of us from getting started. It stopped me for a long time.&lt;/p&gt;
&lt;h2&gt;Beginner's Mind&lt;/h2&gt;
&lt;p&gt;Beginner's mind is a state in which, lacking the knowledge of how hard something is, everything seems easy. There are no boundaries, only possibilities. Beginner's mind is crucial for early learning of a new skill or subject area. With beginner's mind, small improvements seem like major wins. This enthusiasm creates a positive feedback loop, encouraging more learning and skill acquisition.  &lt;/p&gt;
&lt;p&gt;Tech writers don't have beginner's mind. Even if you have never written a line of code in your life, our proximity to software development has shattered any illusions we might have about how easy it is to get an app built and launched. We are aware of all the things that beginners happily ignore --- security, maintainability, deployment, cross-platform compatibility. We've seen too many problems caused by ignoring things. If we ever do sit down to start building a little app or follow along with a tutorial, we are overwhelmed by all the things that are going unmentioned.&lt;/p&gt;
&lt;p&gt;Or maybe I'm the only one.&lt;/p&gt;
&lt;h2&gt;Don't Hope to be a Developer&lt;/h2&gt;
&lt;p&gt;Here's my trick for overcoming this problem --- drastically lower your expectations of what "learning to code" means.&lt;/p&gt;
&lt;p&gt;You already know how hard it is to go from zero (or even 1) to actually-qualified developer. And you've met too many not-actually-qualified developers to have any interest in that path.&lt;/p&gt;
&lt;p&gt;So how do you get started?&lt;/p&gt;
&lt;p&gt;By deciding you are not ever going to write any application code. You are not going to be a developer. You are not even going to be a "coder."&lt;/p&gt;
&lt;p&gt;You are going to be a &lt;em&gt;technical writer with bad coding skills&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;That lowers the bar, doesn't it?&lt;/p&gt;
&lt;h2&gt;Bad Coding Skills&lt;/h2&gt;
&lt;p&gt;What are you going to do with bad coding skills?&lt;/p&gt;
&lt;p&gt;You're not going to become a developer with bad coding skills. (That's not an editorial "you." Lots of people become developers with bad coding skills. You, in particular, are not going to become a developer with bad coding skills.)&lt;/p&gt;
&lt;p&gt;You are going to be a better technical writer. More efficient, happier, and more employable.&lt;/p&gt;
&lt;p&gt;Here a few things I have been able to do since acquiring bad coding skills:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;semi-automate an incredibly boring freelance writing task, letting me earn the same amount of money in about half the time&lt;/li&gt;
&lt;li&gt;easily render HTML from Markdown, automating fussy style rules and naming conventions, saving several minutes and annoyance every day&lt;/li&gt;
&lt;li&gt;switch from WordPress to Jekyll and/or Nikola for my personal blogs, saving money and time&lt;/li&gt;
&lt;li&gt;put "Python" on my resume, greatly increasing the number of interviews and job opportunities I get&lt;/li&gt;
&lt;li&gt;automate documentation deployment ("DocOps")&lt;/li&gt;
&lt;li&gt;write code samples where I actually knew what was going on&lt;/li&gt;
&lt;li&gt;make a code contribution to an Open Source project&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I have not built any apps or launched any products. No one has ever paid me to write code, and I don't think anyone ever will. I don't know how to handle user sessions or deal with cache invalidation. I code slowly, and I Google constantly.&lt;/p&gt;
&lt;p&gt;And, believe me, the code I have written is bad. It's ugly and inefficient. It wouldn't pass a code review.&lt;/p&gt;
&lt;p&gt;But, even though my coding skills are bad, they have made a huge impact in my life. I am more employable, more efficient, more valuable. I'm also happier, and &lt;a href="http://hackwrite.com/posts/third-option-success/"&gt;feel more optimistic about my future&lt;/a&gt;. Bad code works.&lt;/p&gt;
&lt;p&gt;If you have been discouraged, I encourage you. It only takes a little bit --- enough to be dangerous.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Programming as a profession is only moderately interesting. It can be a good job, but you could make about the same money and be happier running a fast food joint. You're much better off using code as your secret weapon in another profession.&lt;/p&gt;
&lt;p&gt;People who can code in the world of technology companies are a dime a dozen and get no respect. People who can code in biology, medicine, government, sociology, physics, history, and mathematics are respected and can do amazing things to advance those disciplines.&lt;/p&gt;
&lt;p&gt;--- Zed Shaw, &lt;a href="http://amzn.to/2iwhe9n"&gt;Learn Python the Hard Way&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2&gt;How (What) To Learn&lt;/h2&gt;
&lt;p&gt;I recommend Python.&lt;/p&gt;
&lt;p&gt;Python is the perfect language for bad coding by non-developers. You can do a lot without knowing very much, and there are a lot of tools for accomplishing non-development tasks --- writing tools, math tools, publishing tools, task automation tools. If you're going to learn to code in order to improve your own life (as opposed to learning to code to get a job or build things) Python is the best option. (It's also good for getting jobs and building things. Learning Python will not limit you.)&lt;/p&gt;
&lt;p&gt;I do not recommend &lt;a href="http://amzn.to/2iwhe9n"&gt;Learn Python the Hard Way&lt;/a&gt;, even though it is very popular. It's out of date and a bit too curmudgeonly.&lt;/p&gt;
&lt;p&gt;The best book (I think) for learning to write Python for life-improvement is &lt;a href="http://amzn.to/2hGOZ6L"&gt;Automate the Boring Stuff with Python&lt;/a&gt;.&lt;/p&gt;</description><guid>http://hackwrite.com/posts/enough-to-be-dangerous/</guid><pubDate>Sun, 01 Jan 2017 14:31:41 GMT</pubDate></item><item><title>"Success and Self-Determination: You Need a Third Option"</title><link>http://hackwrite.com/posts/third-option-success/</link><dc:creator>Adam Michael Wood</dc:creator><description>&lt;blockquote&gt;
&lt;p&gt;I am the master of my fate;&lt;br&gt;
I am the captain of my soul.&lt;br&gt;
— from &lt;em&gt;Invictus&lt;/em&gt;, by William Ernest Henley&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A strong sense of agency --- the feeling that you can, indeed, control the course of your own life --- is an essential element of success.&lt;/p&gt;
&lt;p&gt;Unfortunately, a sense of agency can also be a source of crippling guilt and shame.&lt;/p&gt;
&lt;p&gt;If I am &lt;em&gt;not&lt;/em&gt; the master of my fate, then my lack of success up to this point is not my own fault. There is nothing wrong with me.&lt;/p&gt;
&lt;p&gt;But if I &lt;em&gt;am&lt;/em&gt;, well then --- I have some explaining to do. Why have I not lost the weight, started the business, written the book, built the app?&lt;/p&gt;
&lt;p&gt;When faced with a history of lack of success, and trying to make it over the chasm of despair to a &lt;em&gt;designed life&lt;/em&gt;, we have these two explanations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The world (fate, luck, God, the system, the Man, capitalism) has stopped me. Since the world hasn't changed, I will continue to not succeed.&lt;/li&gt;
&lt;li&gt;I am responsible for my own fate. I have not succeeded so far, and that was my fault. Since I am clearly incapable of success, I will continue not to succeed.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We need a third option. We need a way to take hold of our own personal responsibility and sense of agency, without the guilt and shame that accompanies the recognition that we are responsible up to this point for our failures and lack of success.&lt;/p&gt;
&lt;p&gt;As I write this, I am in my early thirties. I've been trying to learn to play the piano for 15 years, trying lose weight for a decade, trying to become financially independent for eight years, trying to build my dream web app for six or seven, trying to learn to become a developer for five, trying to have a career as a writer for maybe two.&lt;/p&gt;
&lt;p&gt;You can imagine how many of those things I have accomplished. I've lost some weight and put it back on. I was pretty decent on piano for a while but I haven't played regularly in years. I am super bad at Ruby and Python, and only passable in PHP. I make a living as a writer, so there's that --- but I don't like the kind of writing I get paid to do. I've started building my dream web app (&lt;a href="http://hackwrite.com/posts/python-and-django-vs-ruby-and-rails/"&gt;in Django&lt;/a&gt;), but who knows whether that will work out the way I think. I don't even really want to talk about the money issue, but I can tell you that government-funded health "insurance" is going to pay for the birth of my second child in a few months.&lt;/p&gt;
&lt;p&gt;My statements above about the two ways of understanding agency are not theoretical --- this is literally where I am at in my life. I have had, for a long time, a strong sense of agency. Justified or not, I feel that I am &lt;q&gt;the master of my fate, the captain of my soul.&lt;/q&gt;&lt;/p&gt;
&lt;p&gt;So how can I effectively move forward? How can I shake off the guilt and regret of not having achieved very much at all up to this point, without giving up my sense that I am in control?&lt;/p&gt;
&lt;p&gt;I need a third option. We all need a third option.&lt;/p&gt;
&lt;p&gt;This needs a little work (you can help in the comments), but I think that third option is something like this:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I &lt;em&gt;am indeed&lt;/em&gt; the master of my fate. The world is indifferent, so I am responsible for my own success or failure. There was &lt;em&gt;some specific thing&lt;/em&gt; which I previously lacked, but was unaware of. Having become aware, I can move forward.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For me, that specific thing is a way of thinking about problems the way a developer thinks about problems. Learning to be a developer is (slowly) teaching me to develop myself. Even though I have been piddling around with PHP (and mostly WordPress) for four or five years, I have found that taking up Python development --- and also actually bothering to get good at the terminal, at git, at Linux, at setting up virtual environments, etc., etc., --- has changed the way I approach problems. I am further convinced that --- for me --- this different approach is what has been lacking.&lt;/p&gt;
&lt;p&gt;For me, learning to be a developer (&lt;b&gt;n.b.&lt;/b&gt; not just a coder) is my third option.&lt;/p&gt;
&lt;p&gt;What is your third option?&lt;/p&gt;</description><guid>http://hackwrite.com/posts/third-option-success/</guid><pubDate>Sat, 13 Feb 2016 15:26:43 GMT</pubDate></item><item><title>Python and Django vs. Ruby and Rails</title><link>http://hackwrite.com/posts/python-and-django-vs-ruby-and-rails/</link><dc:creator>Adam Michael Wood</dc:creator><description>&lt;p&gt;&lt;em&gt;tl;dr - Python.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I can't even begin to count how many forum posts and deleted Stack Overflow questions there are boiling down to some version of &lt;em&gt;Python vs. Ruby&lt;/em&gt; or, more specifically, &lt;em&gt;Django vs. Rails&lt;/em&gt;. Google (as of right now) has &lt;a href="https://en.wiktionary.org/wiki/buttload"&gt;NINE POINT EIGHT MILLION&lt;/a&gt; results for &lt;a href="https://www.google.com/webhp?sourceid=chrome-instant&amp;amp;ion=1&amp;amp;espv=2&amp;amp;ie=UTF-8#safe=off&amp;amp;q=python+vs.+ruby"&gt;"Python vs. Ruby"&lt;/a&gt;, which is basically insane.&lt;/p&gt;
&lt;p&gt;Unfortunately many of the articles and posts answering the question don't actually answer it. They provide some generalizations about each, talk about some of the differences, and say that it's up to you.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Have an opinion, you soulless producers of Search Engine fodder!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I have recently spent a bunch of time trying to answer this question as I attempt to transition out of the wasteland of PHP and WordPress. I have a particular app I'm trying to build, and it is just the sort of content-driven, database-backed, CRUD app that both Ruby on Rails and Django are perfectly suited for. (And that WordPress &lt;del&gt;idiots&lt;/del&gt; evangelists would claim would be just perfect as a custom plugin, except that's a &lt;em&gt;terrible idea&lt;/em&gt;.)&lt;/p&gt;
&lt;p&gt;So here is the definitive answer...&lt;/p&gt;
&lt;p&gt;Use Python, and Django, if you care about any of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Schema design&lt;/li&gt;
&lt;li&gt;Data analytics&lt;/li&gt;
&lt;li&gt;Programming best practices&lt;/li&gt;
&lt;li&gt;Learning how to actually program&lt;/li&gt;
&lt;li&gt;Database integrity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, use Python, and (if needed) Django, if you are working in any of the following domains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Math&lt;/li&gt;
&lt;li&gt;Science&lt;/li&gt;
&lt;li&gt;Music&lt;/li&gt;
&lt;li&gt;Signal Processing&lt;/li&gt;
&lt;li&gt;AI&lt;/li&gt;
&lt;li&gt;Analytics (which is really math)&lt;/li&gt;
&lt;li&gt;Statistics (more math)&lt;/li&gt;
&lt;li&gt;Academia (most likely math)&lt;/li&gt;
&lt;li&gt;Engineering&lt;/li&gt;
&lt;li&gt;Remotely serious gaming&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;li&gt;Networking&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Use Ruby if you want to use Rails. And use Rails if you care about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Getting a &lt;del&gt;stupid&lt;/del&gt; &lt;ins&gt;clever&lt;/ins&gt; social media app MVP up and running as soon as possible&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span title="Actually it is."&gt;This isn't really a judgement on the quality of either language.&lt;/span&gt; &lt;span title="But I will anyway."&gt;I am not in a position to say which language is intrinsically better suited for either task.&lt;/span&gt; (And neither are most of the people blogging on this subject.)&lt;/p&gt;
&lt;p&gt;What matters in either case is the community of people who have gravitated to each language and (therefore) what kinds of tools are available for each. Also, the focus of the two disparate communities has impacted the design of Django and Rails in different ways.&lt;/p&gt;
&lt;p&gt;So, who uses Python? Nerds, mostly. Sciencey people. Math people. People who care about data. People who know three or four or a dozen other programming languages. People who prefer PostgreSQL to MongoDB, because they care about things like data integrity. People who actually understand what polymorphism is. People who want to teach computers to write music or recognize handwriting.&lt;/p&gt;
&lt;p&gt;Because these are the kind of people who have gotten into Python, the tools exist in Python to do that kind of work. And because those tools exist, more and more of those kinds of people have gravitated to the language, generating a positive feedback loop and a network effect of geeky awesomeness.&lt;/p&gt;
&lt;p&gt;And who uses Ruby? People who want to get rich building the next Twitter.&lt;/p&gt;
&lt;p&gt;Compare the contents of Python's &lt;a href="https://pypi.python.org/pypi?%3Aaction=browse"&gt;package index&lt;/a&gt; against the &lt;a href="https://rubygems.org/gems"&gt;Ruby gems library&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span title="Yes it is."&gt;This is not a moral judgement.&lt;/span&gt; I would love to get rich building the next Twitter. But since a deep understanding of either language, either platform, can be a ticket to a lucrative career, I think it makes more sense to focus on a language and community that has more interesting possibilities. (And it's not like you &lt;em&gt;can't&lt;/em&gt; build the next Twitter on Django.)&lt;/p&gt;
&lt;p&gt;These differences in focus and culture manifest in non-trivial differences between Django and Rails. One difference in particular sealed the deal for me in selecting Django (and, by extension, Python) for my next project, even though I was already leaning in that direction.&lt;/p&gt;
&lt;p&gt;I am working on a library-catalog-like index of church music --- everything from Gregorian Chant to Christian Pop, including tons of information about liturgy (rituals), history, legislation and a hundred other things you wouldn't understand unless you really cared about church music. The corpus is unbelievable large and just wrapping one's head around how the data should be organized is difficult.&lt;/p&gt;
&lt;p&gt;One tiny, nearly non-trivial example of one of the data modeling problems: A hymn consists of a tune and a text. A tune can have multiple harmonizations, but it is possible that one is "canonical." Texts might be paired with different tunes over time (for example, there are at least &lt;a href="https://www.youtube.com/watch?v=MTPyKwqUUgc"&gt;two&lt;/a&gt; &lt;a href="https://www.youtube.com/watch?v=Lj2fwME46GM"&gt;different&lt;/a&gt; well-known tunes for the Christmas Hymn &lt;em&gt;O Little Town of Bethlehem&lt;/em&gt;.) And the tunes often end up paired to different texts over time. Sometimes these pairings are "canonical" or widely recognized, while other times they are one-off pairings that appear only in a single book or hymnal. And sometimes a tune and text simply cannot be separated, because they were written together and form a singular unit. And sometimes that happens, but someone else still comes behind and writes a new tune for the text.&lt;/p&gt;
&lt;p&gt;Another issue... authors of texts and tunes. Most texts are written by individual people. But some are written by groups, like a worship committee or church council. Others are traditional or anonymous. Some are attributed to a particular person, but he or she probably didn't actually write it. Some attributions are apocryphal, others are doubtful but possible, some fraudulent or spurious, and so on.&lt;/p&gt;
&lt;p&gt;And the possibilities for relationships between authors and texts, is the same as for composers and tunes --- so &lt;span title="Yes, it should be."&gt;shouldn't that be abstracted?&lt;/span&gt; And therefore &lt;span title="Yes, again."&gt;shouldn't tunes and texts (and books and arrangements and sermons and pamphlets) be abstracted to something like &lt;code&gt;Works&lt;/code&gt;&lt;/span&gt;? And since people and groups can both be contributors, &lt;span title="Still yes."&gt;shouldn't they be abstracted into something like &lt;code&gt;Entities&lt;/code&gt;&lt;/span&gt;?&lt;/p&gt;
&lt;p&gt;Trying to capture all of these different relationships, and the meta-data under the relationships (&lt;em&gt;What type of tune-text pairing?&lt;/em&gt; &lt;em&gt;What degree of certainty does an attribution have?&lt;/em&gt;) is a big undertaking. To get it right, I need a pretty high degree of control over the database schema.&lt;/p&gt;
&lt;p&gt;That &lt;em&gt;could&lt;/em&gt; mean writing SQL from scratch and using a framework that doesn't have a built-in abstraction layer, which would be great if I wanted to go completely insane.&lt;/p&gt;
&lt;p&gt;Or it &lt;em&gt;could&lt;/em&gt; mean basically hacking Ruby on Rails, relying on a &lt;a href="https://github.com/hzamani/acts_as_relation"&gt;poorly supported plugin&lt;/a&gt; or &lt;a href="https://dan.chak.org/enterprise-rails/chapter-10-multiple-table-inheritance/"&gt;reading way too much&lt;/a&gt; to accomplish multi-table inheritance.&lt;/p&gt;
&lt;p&gt;Or I could just use Django, which &lt;a href="https://docs.djangoproject.com/en/1.9/topics/db/models/#multi-table-inheritance"&gt;natively and simply supports multi-table inheritance&lt;/a&gt;, and provides pretty real polymorphism with a &lt;a href="https://django-polymorphic.readthedocs.org/en/latest/quickstart.html"&gt;well-documented, actively developed plugin&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;(And if you want to jump all over me about performance issues with concrete inheritance and left joins, &lt;em&gt;fuck off&lt;/em&gt;. I will take a data model that reflects reality over cargo-cult performance superstitions any day. Besides, I'm not building 911 dispatch or a global e-commerce site. I'm indexing hymnals for church musicians.)&lt;/p&gt;
&lt;p&gt;This one example --- how each framework deals with model inheritance --- is indicative of a larger trend I found when trying to mockup various pieces of my system in both platforms: Django gives you more control over the data model. There's still an abstraction layer, but it was written by people who care about schema --- not people who are trying to hide it from you. Since I care about data models also (maybe you don't), this is a killer feature.&lt;/p&gt;
&lt;p&gt;It doesn't hurt that if I want to do anything remotely interesting with all the music data I plan to &lt;del&gt;&lt;a href="http://scrapy.org/"&gt;steal&lt;/a&gt;&lt;/del&gt; &lt;ins&gt;collect&lt;/ins&gt;, I'll want to do that sort of thing in Python.&lt;/p&gt;
&lt;p&gt;Analyze all the hymn tunes written in 17th century Germany in order to programatically create new tunes in the same style?&lt;/p&gt;
&lt;p&gt;Yeah, I could totally do that in Ruby.&lt;/p&gt;
&lt;p&gt;So... bottom line: If you are learning to code because you want to be an entrepreneur, &lt;span title="Or, better yet, hire a developer."&gt;learn Ruby on Rails&lt;/span&gt;. If you are learning to code because you want to do unique and interesting things as a developer, learn Python.&lt;/p&gt;</description><guid>http://hackwrite.com/posts/python-and-django-vs-ruby-and-rails/</guid><pubDate>Wed, 10 Feb 2016 23:22:39 GMT</pubDate></item></channel></rss>